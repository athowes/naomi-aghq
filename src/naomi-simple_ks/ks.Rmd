---
title: "Inference methods comparison for the simplified Naomi model using the Kolmogorov-Smirnov test statistic"
author:
- name: Adam Howes
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
abstract: |
  **Background**  We have run the simplified Naomi model using a range of inference methods: `TMB`, `aghq`, `adam` and `tmbstan`.
  
  **Task** In this report, we compare the accuracy of the posterior distributions obtained from these inference methods using histograms and Kolmogorov-Smirnov tests.
---

# Background

We compare the inference results from `TMB`, `aghq`, `adam`, and `tmbstan`.
Import these inference results as follows:

```{r}
tmb <- readRDS("depends/tmb.rds")
aghq <- readRDS("depends/aghq.rds")
adam <- readRDS("depends/adam.rds")
adam_time <- adam$time
adam <- adam$adam
tmbstan <- readRDS("depends/tmbstan.rds")

depends <- yaml::read_yaml("orderly.yml")$depends
```

Check that the parameters (latent field, hyperparameters, model outputs) sampled from each of the four methods are the same:

```{r}
stopifnot(names(tmb$fit$sample) == names(aghq$quad$sample))
stopifnot(names(tmb$fit$sample) == names(adam$adam$sample))
stopifnot(names(tmb$fit$sample) == names(tmbstan$mcmc$sample))
```

## Run details {.tabset}

For more information about the conditions under which these results were generated, see:

### `TMB`

```{r}
dependency_details <- function(i) {
  report_name <- names(depends[[i]])
  print(paste0("Inference results obtained from ", report_name, " with the query ", depends[[i]][[report_name]]$id))
  report_id <- orderly::orderly_search(query = depends[[i]][[report_name]]$id, report_name)
  print(paste0("Obtained report had ID ", report_id, " and was run with the following parameters:"))
  print(orderly::orderly_info(report_id, report_name)$parameters)
}

dependency_details(1)
```

### `aghq`

```{r}
dependency_details(2)
```

### `adam`

```{r}
dependency_details(3)
```

### `tmbstan`

```{r}
tmbstan_details <- dependency_details(4)
tmbstan_details
```

## Time taken

```{r}
time_taken <- data.frame(
  "TMB" = tmb$time,
  "aghq" = aghq$time,
  "adam" = adam_time,
  "tmbstan" = tmbstan$time
)

write_csv(time_taken, "time_taken.csv")

time_taken
```

# Histograms and ECDF difference plots {.tabset .tabset-fade}

We create histograms and empirical cumulative distribution function (ECDF) difference plots of the samples from each method.
All of the possible latent field and hyperparamter names are given by `pars`:

```{r}
pars <- names(tmb$fit$sample)
```

There are also all of the Naomi outcome variables:

```{r}
names(tmb$fit$sample)[!(names(tmb$fit$sample) %in% unique(names(tmb$fit$obj$env$par)))]
```

We will especially focus on the outputs:

* HIV prevalence (`rho_t1_out`) which has `r dim(tmb$fit$sample$rho_t1_out)[1]` variables (rows)
* ART coverage (`alpha_t1_out`) which has `r dim(tmb$fit$sample$alpha_t1_out)[1]` variables (rows)
* HIV incidence (`lambda_t1_out`) which has `r dim(tmb$fit$sample$lambda_t1_out)[1]` variables (rows)

These outputs are at an aggregate resolution as well as at the finest resolution.
It seems to make sense to only to assess inferential accuracy at the finest resolution so as to avoid double counting.
As such, we need to find the subset of these variables at the finest resolution.
Within `tmb$naomi_data` there is a dataframe called `mf_out` (model frame output) which contains the area, age, sex mapping for these `r dim(tmb$fit$sample$rho_t1_out)[1]` rows.
As a sanity check, confirm that the number of areas times number of ages times number of sexes indeed equals the number of rows:

```{r}
mf_out <- tmb$naomi_data$mf_out
(n_area <- length(unique(mf_out$area_id)))
(n_age <- length(unique(mf_out$age_group)))
(n_sex <- length(unique(mf_out$sex)))

stopifnot(n_area * n_age * n_sex == dim(tmb$fit$sample$rho_t1_out)[1])
```

The unique levels for area, age and sex are:

```{r}
mf_out$area_id %>% unique()
mf_out$age_group %>% unique()
mf_out$sex %>% unique()
```

Filter to only the finest resolution, adding an `id` column has to enable merging to the samples:

```{r}
mf_out_fine <- mf_out %>%
  tibble::rownames_to_column("id") %>%
  mutate(id = as.numeric(id)) %>%
  filter(
    area_id %in% paste0("MWI_4_", 1:32, "_demo"),
    sex %in% c("male", "female"),
    age_group %in%
      c(
        "Y000_004", "Y005_009", "Y010_014", "Y015_019", "Y020_024", "Y025_029",
        "Y025_034", "Y030_034", "Y035_039", "Y040_044", "Y045_049", "Y050_054",
        "Y055_059", "Y060_064", "Y065_069", "Y070_074", "Y075_079", "Y080_999"
      )
  )
```

We will produce plots about the a small subset of parameters for the time being.
There is no particular reason to choose this subset rather than other, it's quite arbitrary.

```{r}
pars_eval <- pars %in% c("beta_rho", "u_rho_x")
names(pars_eval) <- pars
```

```{r}
histogram_and_ecdf_helper <- function(par) lapply(1:sum(names(tmb$fit$obj$env$par) == par), histogram_and_ecdf, par = par)
```

## `beta_rho`

```{r eval = pars_eval[["beta_rho"]]}
histogram_and_ecdf_helper("beta_rho")
```

## `beta_alpha`

```{r eval = pars_eval[["beta_rho"]]}
histogram_and_ecdf_helper("beta_alpha")
```

## `beta_lambda`

```{r eval = pars_eval[["beta_rho"]]}
histogram_and_ecdf_helper("beta_lambda")
```

## `beta_anc_rho`

```{r eval = pars_eval[["beta_rho"]]}
histogram_and_ecdf("beta_anc_rho")
```

## `beta_anc_alpha`

```{r eval = pars_eval[["beta_rho"]]}
histogram_and_ecdf("beta_anc_alpha")
```

## `logit`

```{r eval = FALSE}
lapply(pars[stringr::str_starts(pars, "logit")], histogram_and_ecdf)
```

## `log_sigma`

```{r eval = FALSE}
lapply(pars[stringr::str_starts(pars, "log_sigma")], histogram_and_ecdf)
```

## `u_rho_x`

```{r eval = pars_eval[["u_rho_x"]]}
histogram_and_ecdf_helper("u_rho_x")
```

## `us_rho_x`

```{r eval = pars_eval[["us_rho_x"]]}
histogram_and_ecdf_helper("us_rho_x")
```

## `u_rho_xs`

```{r eval = pars_eval[["u_rho_xs"]]}
histogram_and_ecdf_helper("u_rho_xs")
```

## `us_rho_xs`

```{r eval = pars_eval[["us_rho_xs"]]}
histogram_and_ecdf_helper("us_rho_xs")
```

## `u_rho_as`

```{r eval = pars_eval[["u_rho_as"]]}
histogram_and_ecdf_helper("u_rho_as")
```

## `u_alpha_x`

```{r eval = pars_eval[["u_alpha_x"]]}
histogram_and_ecdf_helper("u_alpha_x")
```

## `us_alpha_x`

```{r eval = pars_eval[["us_alpha_x"]]}
histogram_and_ecdf_helper("us_alpha_x")
```

## `u_alpha_xs`

```{r eval = pars_eval[["u_alpha_xs"]]}
histogram_and_ecdf_helper("u_alpha_xs")
```

## `us_alpha_xs`

```{r eval = pars_eval[["beta_rho"]]}
histogram_and_ecdf_helper("us_alpha_xs")
```

## `u_alpha_a`

```{r eval = pars_eval[["u_alpha_a"]]}
histogram_and_ecdf_helper("u_alpha_a")
```

## `u_alpha_as`

```{r eval = pars_eval[["u_alpha_as"]]}
histogram_and_ecdf_helper("u_alpha_as")
```

## `u_alpha_xa`

```{r eval = pars_eval[["u_alpha_xa"]]}
histogram_and_ecdf_helper("u_alpha_xa")
```

## `ui_lambda_x`

```{r eval = pars_eval[["ui_lambda_x"]]}
histogram_and_ecdf_helper("ui_lambda_x")
```

## `ui_anc_rho_x`

```{r eval = pars_eval[["ui_anc_rho_x"]]}
histogram_and_ecdf_helper("ui_anc_rho_x")
```

## `ui_anc_alpha_x`

```{r eval = pars_eval[["ui_anc_alpha_x"]]}
histogram_and_ecdf_helper("ui_anc_alpha_x")
```

## `log_or_gamma`

```{r eval = pars_eval[["log_or_gamma"]]}
histogram_and_ecdf_helper("log_or_gamma")
```

## `rho_t1_out`

There are too many variables to plot this here!

## `alpha_t1_out`

There are too many variables to plot this here!

## `lambda_t1_out`

There are too many variables to plot this here!

# KS plots 

## Individual parameters {.tabset .tabset-fade}

```{r}
ks_helper <- function(par, starts_with = FALSE, ...) {
  to_ks_df(par, starts_with = starts_with) %>% ks_plot(par, ...)
}

ks_df_out <- function(par) {
  to_ks_df(par = par, outputs = TRUE, id = mf_out_fine$id) %>%
  select(-par) %>%
  left_join(
    mf_out_fine %>%
      rename("full_id" = "id") %>%
      tibble::rowid_to_column("index") %>%
      mutate(index = as.numeric(index))
  )
}
```

### `beta`

```{r}
ks_helper("beta", starts_with = TRUE)

#' Save off KS results for one parameter as example
saveRDS(
  to_ks_df(par = "beta_alpha", starts_with = TRUE),
  file = "beta_alpha.rds"
)
```

### `logit`

```{r}
ks_helper("logit", starts_with = TRUE)
```

### `log_sigma`

```{r}
ks_helper("log_sigma", starts_with = TRUE)
```

### `u_rho_x`

```{r eval = pars_eval[["u_rho_x"]]}
ks_helper("u_rho_x")
```

### `u_rho_xs`

```{r eval = pars_eval[["u_rho_xs"]]}
ks_helper("u_rho_xs")
```

### `us_rho_x`

```{r eval = pars_eval[["us_rho_x"]]}
ks_helper("us_rho_x")
```

### `us_rho_xs`

```{r eval = pars_eval[["us_rho_xs"]]}
ks_helper("us_rho_xs")
```

### `u_rho_a`

```{r eval = pars_eval[["u_rho_a"]]}
ks_helper("u_rho_a")
```

### `u_rho_as`

```{r eval = pars_eval[["u_rho_as"]]}
ks_helper("u_rho_as")
```

### `u_alpha_x`

```{r eval = pars_eval[["u_alpha_x"]]}
ks_helper("u_alpha_x")
```

### `u_alpha_xs`

```{r eval = pars_eval[["u_alpha_xs"]]}
ks_helper("u_alpha_xs")
```

### `us_alpha_x`

```{r eval = pars_eval[["us_alpha_x"]]}
ks_helper("us_alpha_x")
```

### `us_alpha_xs`

```{r eval = pars_eval[["us_alpha_xs"]]}
ks_helper("us_alpha_xs")
```

### `u_alpha_a`

```{r eval = pars_eval[["u_alpha_a"]]}
ks_helper("u_alpha_a")
```

### `u_alpha_as`

```{r eval = pars_eval[["u_alpha_as"]]}
ks_helper("u_alpha_as")
```

### `u_alpha_xa`

```{r eval = pars_eval[["u_alpha_xa"]]}
ks_helper("u_alpha_xa")
```

### `ui_anc_rho_x`

```{r eval = pars_eval[["ui_anc_rho_x"]]}
ks_helper("ui_anc_rho_x")
```

### `ui_anc_alpha_x`

```{r eval = pars_eval[["ui_anc_alpha_x"]]}
ks_helper("ui_anc_alpha_x")
```

### `log_or_gamma`

```{r eval = pars_eval[["log_or_gamma"]]}
ks_helper("log_or_gamma")
```

### `rho_t1_out`

```{r}
ks_df_out(par = "rho_t1_out") %>%
  ks_plot(par = "rho_t1_out", alpha = 0.2)
```

### `alpha_t1_out`

```{r}
ks_df_out(par = "alpha_t1_out") %>%
  ks_plot(par = "rho_t1_out", alpha = 0.2)
```

### `lambda_t1_out`

```{r}
ks_df_out(par = "lambda_t1_out") %>%
  filter(!age_group %in% c("Y005_009", "Y010_014", "Y080_999")) %>%
  ks_plot(par = "lambda_t1_out", alpha = 0.2)
```

Filter out the age group 5-9, 10-14 and 80+ here because there are new new infections in those age groups, and the posterior samples from each method are exactly the same: in particular draws of identically zero.

```{r}
# ks_lambda_t1_out %>%
#   filter(ks == 0) %>%
#   group_by(method) %>%
#   summarise(n = n())
# 
# ks_lambda_t1_out %>%
#   filter(ks == 0) %>%
#   pull(age_group) %>%
#   unique()
```

## Summary {.tabset .tabset-fade}

Values in dark blue are the lowest KS difference for that particular parameter:

```{r class.source = 'fold-hide'}
options(dplyr.summarise.inform = FALSE)

ks_summary <- lapply(unique(names(tmb$fit$obj$env$par)), function(x) {
  to_ks_df(x) %>%
    group_by(method, index) %>%
    summarise(ks = mean(ks), par = x) %>%
    ungroup()
}) %>%
  bind_rows() %>%
  pivot_wider(names_from = "method", values_from = "ks") %>%
  rename(
    "Parameter" = "par",
    "KS(adam, tmbstan)" = "adam",
    "KS(aghq, tmbstan)" = "aghq",
    "KS(TMB, tmbstan)" = "TMB",
  )

r <- adam$quad$obj$env$random
x_names <- names(adam$quad$obj$env$par[r])
theta_names <- names(adam$quad$obj$env$par[-r])

dict <- data.frame(
  Parameter = c(unique(x_names), unique(theta_names)),
  Type = c(rep("Latent field", length(unique(x_names))), rep("Hyper", length(unique(theta_names))))
)

ks_summary <- ks_summary %>%
  left_join(dict, by = "Parameter")

saveRDS(ks_summary, "ks_summary.rds")

ks_summary %>%
  filter(Type != "Hyper") %>%
  ks_plot_many("TMB", "aghq")
```

```{r}
ks_summary %>%
  group_by(Type) %>%
  summarise(
    TMB = mean(`KS(TMB, tmbstan)`),
    aghq = mean(`KS(aghq, tmbstan)`),
    adam = mean(`KS(adam, tmbstan)`)
  ) %>%
  gt::gt()
```

### Latent field

```{r}
ks_summary %>%
  filter(Type == "Latent field") %>%
  group_by(Parameter) %>%
  summarise(
    `KS(TMB, tmbstan)` = mean(`KS(TMB, tmbstan)`),
    `KS(aghq, tmbstan)` = mean(`KS(aghq, tmbstan)`),
    `KS(adam, tmbstan)` = mean(`KS(adam, tmbstan)`)
  ) %>%
  ks_table()
```


### Hyperparameters

```{r}
# ks_summary %>%
#   filter(Type == "Hyper") %>%
#   group_by(Parameter) %>%
#   summarise(
#     `KS(TMB, tmbstan)` = mean(`KS(TMB, tmbstan)`),
#     `KS(aghq, tmbstan)` = mean(`KS(aghq, tmbstan)`),
#     `KS(adam, tmbstan)` = mean(`KS(adam, tmbstan)`)
#   ) %>%
#   ks_table()
```

### Outputs

```{r}
#' To-do
```

## Investigation into large KS values

Want to create rank order lists of largest KS differences between methods:

```{r}
ks_comparison <- function(ks_summary, method1, method2, n) {
  ks_method1 <- paste0("KS(", method1, ", tmbstan)")
  ks_method2 <- paste0("KS(", method2, ", tmbstan)")
  ks_summary[["KS difference"]] <- ks_summary[[ks_method1]] - ks_summary[[ks_method2]]
  ks_summary %>%
    filter(Type != "Hyper") %>%
    arrange(desc(`KS difference`)) %>%
    head(n = n)
}
```

### Nodes where `TMB` beats `aghq`

```{r}
ks_comparison(ks_summary, method1 = "aghq", method2 = "TMB", 10)

histogram_and_ecdf(par = "us_rho_x", i = 19)
histogram_and_ecdf(par = "ui_anc_rho_x", i = 2)
histogram_and_ecdf(par = "u_rho_x", i = 2)
```

### Nodes where `aghq` beats `TMB`

```{r}
ks_comparison(ks_summary, method1 = "TMB", method2 = "aghq", 10)  

histogram_and_ecdf(par = "us_alpha_xs", i = 18)
histogram_and_ecdf(par = "us_alpha_xs", i = 30)
histogram_and_ecdf(par = "u_alpha_xa", i = 10)
```

## Correlation between KS values and ESS

Is there any correlation between the value of $\text{KS}(\texttt{method}, \texttt{tmbstan})$ for a particular parameter and the ESS of that parameter from `tmbstan` output?

```{r}
rhats <- bayesplot::rhat(tmbstan$mcmc$stanfit)
ess_ratio <- bayesplot::neff_ratio(tmbstan$mcmc$stanfit)
niter <- 4 * tmbstan_details$niter / tmbstan_details$nthin
ess <- ess_ratio * niter

ks_summary %>%
  pivot_longer(
    col = starts_with("KS"),
    names_to = "Method",
    values_to = "KS"
  ) %>%
  mutate(
    Method = fct_recode(Method,
      "adam" = "KS(adam, tmbstan)",
      "aghq" = "KS(aghq, tmbstan)",
      "TMB" = "KS(TMB, tmbstan)"
    )
  ) %>%
  group_by(Parameter) %>%
  mutate(
    par_num = case_when(
      max(index) > 1 ~ paste0(Parameter, "[", index, "]"),
      TRUE ~ Parameter
    )
  ) %>%
  ungroup() %>%
  left_join(data.frame(ess) %>%
    tibble::rownames_to_column("par_num")
  ) %>%
  ggplot(aes(x = ess, y = KS)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", color = "#56B4E9") +
    facet_grid(~ Method) +
    theme_minimal() +
    labs(x = "ESS", y = "KS(method, tmbstan)")
```
