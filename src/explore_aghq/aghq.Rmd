---
title: "Understanding the `aghq` package"
author:
- name: Adam Howes
output:
  html_document:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
abstract: |
  **Background**
  
  **Task**
---

# Basic

```{r}
set.seed(84343124)
y <- rpois(10, 5)
plot(y)

log_post <- function(eta, y) {
  sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y + 1)) + eta
}

fn <- function(x) log_post(x, y)
gr <- function(x) numDeriv::grad(fn, x)
he <- function(x) numDeriv::hessian(fn, x)

ff <- list(fn = fn, gr = gr, he = he)

quad <- aghq::aghq(ff = ff, k = 3, startingvalue = 0)

class(quad)

summary(quad)
plot(quad)

# Containing
str(quad)
# normalized_posterior
quad$normalized_posterior$nodesandweights
quad$normalized_posterior$lognormconst
# marginals
# optresults
quad$optresults$mode
```

# Background

```{r}

# Quadrature

# Single dimensional example
f <- function(x) {
  exp(-(x^2) / 2)  
}

# Grid for GHQ with 3 points
gg <- mvQuad::createNIGrid(1, "GHe", 3)
mvQuad::quadrature(f, gg)
sqrt(2 * pi)

mvQuad::getNodes(gg)
mvQuad::getWeights(gg)

# Two dimensional example
f <- function(x) {
  apply(x, 1, function(y) prod(exp(-(y^2) / 2)))  
}

# Still 3 points (per dimension I'd guess)
gg2 <- mvQuad::createNIGrid(2, "GHe", 3)

mvQuad::getNodes(gg2)
# which is equivalent to
expand.grid(mvQuad::getNodes(gg),mvQuad::getNodes(gg))

mvQuad::getWeights(gg2)
# which is equivalent to
cbind(apply(expand.grid(mvQuad::getWeights(gg),mvQuad::getWeights(gg)),1,prod))

mvQuad::quadrature(f, gg2)
2 * pi

# Gauss Hermite Quadrature
# Showing that the nodes are zeros of Hermite polynomial
Hk <- as.function(mpoly::hermite(3, kind = "he"))
nn <- mvQuad::getNodes(gg)
round(Hk(nn))

# Adaptive: scale the nodes and weights by the mode and curvature
theta_hat <- c(2, 3)
theta_hess <- matrix(c(3, 1, 1, 5), nrow = 2, ncol = 2)
theta_hess_inv <- solve(theta_hess)
k <- 3

# Can be rescaled using mvQuad via
int_grid_software <- mvQuad::createNIGrid(2, "GHe", k)
mvQuad::rescale(int_grid_software, m = theta_hat, C = theta_hess_inv, dec.type = 2)
# or manually via
int_grid_manual <- mvQuad::createNIGrid(2, "GHe", k)
nn_rescaled <- mvQuad::getNodes(int_grid_manual) %*% chol(theta_hess_inv)
nn_rescaled[, 1] <- nn_rescaled[, 1] + theta_hat[1]
nn_rescaled[, 2] <- nn_rescaled[, 2] + theta_hat[2]
# and for the weights
mvQuad::getWeights(int_grid_software)
ww_rescaled <- mvQuad::getWeights(int_grid_manual) * det(chol(theta_hess_inv))

# k = 1 then ACHQ is a Laplace approximation
```

# Tomato disease example

```{r}
library(TMB)
data("tswv", package = "EpiILMCT")

precompile()
compile("disease.cpp")
dyn.load(dynlib("disease"))

dat <- tswv$tswvsir
dat$epidat <- dat$epidat[order(dat$epidat[, 4]), ]
I <- dat$epidat[, 4]
R <- dat$epidat[, 2]
infected <- !is.infinite(I)

datlist <- list(
  D = as.matrix(dist(dat$location[dat$epidat[, 1], ])),
  I = I,
  R = R,
  infected = as.numeric(infected[infected])
)

ff <- TMB::MakeADFun(
  data = datlist,
  parameters = list(theta1 = 0, theta2 = 0),
  DLL = "disease",
  ADreport = FALSE,
  silent = TRUE
)

tm <- Sys.time()
# c(0, 0) is start and k = 7, ilm = individual-level model (?)
tmp <- capture.output(
  ilmquadrature <- aghq::aghq(ff, 7, c(0, 0))
)
runtime <- difftime(Sys.time(), tm, units = "secs")

summary(ilmquadrature)

# compute_moment is the mean (only?)
ilm_means <- aghq::compute_moment(ilmquadrature$normalized_posterior, function(x) exp(x))
names(ilm_means) <- c("alpha", "beta")

# q is a vector of numeric values in (0, 1) giving the quantiles you want
my_q <- c(0.025, 0.1, 0.5, 0.9, 0.975)
exp(aghq::compute_quantiles(ilmquadrature$marginals[[1]], q = my_q)) # alpha
exp(aghq::compute_quantiles(ilmquadrature$marginals[[2]], q = my_q)) # beta
```
