---
title: "Understanding the `aghq` package"
author:
- name: Adam Howes
output:
  html_document:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
abstract: |
  **Background**
  
  **Task**
---

```{r}
cbpalette <- multi.utils::cbpalette()
```

# Basic usage

Data:

```{r}
set.seed(84343124)
y <- rpois(10, 5)
plot(y)
```

The log-posterior for the model is:

```{r}
log_post <- function(eta, y) {
  sum(y) * eta - (length(y) + 1) * exp(eta) - sum(lgamma(y + 1)) + eta
}
```

Get the first two derivatives too, and put them into a list:

```{r}
fn <- function(x) log_post(x, y)
gr <- function(x) numDeriv::grad(fn, x)
he <- function(x) numDeriv::hessian(fn, x)

ff <- list(fn = fn, gr = gr, he = he)
```

Use the `aghq` package with `k = 3`:

```{r}
quad <- aghq::aghq(ff = ff, k = 3, startingvalue = 0)
```

The result is of class `"aghq"`:

```{r}
class(quad)
```

```{r}
summary(quad)
plot(quad)
```

The `quad` object contains:

```{r}
str(quad)
```

The nodes and weights of the posterior are:

```{r}
quad$normalized_posterior$nodesandweights
```

The logarithm of the normalising constant (should correspond to `logpost - logpost_normalized`):

```{r}
quad$normalized_posterior$lognormconst
```

The mode is as follows, which corresponds to the second node.
For `k = 3`, and other odd numbers, the mode is included as a node.

```{r}
quad$optresults$mode
```

# More detailed background

## One dimensional example

Suppose we have
$$
f(x) = \exp(-\frac{x^2}{2}),
$$
which we would like to integrate over $\mathbb{R}$, i.e. $\int_{-\infty}^\infty f(x) \text{d}x$.

```{r}
f <- function(x) {
  exp(-(x^2) / 2)  
}
```

```{r}
plot <- data.frame(x = seq(from = -10, to = 10, by = 0.1)) %>%
  mutate(
    y = f(x)
  ) %>%
  ggplot(aes(x = x, y = y)) +
    geom_line() +
    theme_minimal()

plot
```


Going to do Gauss-Hermite quadrature with `k = 3` points:

```{r}
gg <- mvQuad::createNIGrid(1, "GHe", 3)
```

The positions of the nodes and their weights are:

```{r}
gg$nodes
gg$weights

#' The scale for weights is a bit silly
plot +
  geom_point(
    data = data.frame(nodes = gg$nodes, weights = gg$weights, y = 0), 
    aes(x = nodes, y = y, size = weights),
    col = cbpalette[2]
  )
```

We can perform the quadrature using `mvQuad` via:

```{r}
mvQuad::quadrature(f, gg)
```

Or more manually via:

```{r}
sum(f(gg$nodes) * gg$weights)

#' Note: you can also use these functions to get the nodes and weights
# mvQuad::getNodes(gg)
# mvQuad::getWeights(gg)
```

This is surprisingly close to the real answer, which is:

```{r}
sqrt(2 * pi)
```

## Two dimensional example

What about in two dimensions?

```{r}
f <- function(x) {
  prod(exp(-(x^2) / 2))
}

df <- expand.grid(
  x1 = seq(-3, 3, by = 0.1),
  x2 = seq(-3, 3, by = 0.1)
)

plot2 <- df %>%
  rowwise() %>%
  mutate(
    y = f(c(x1, x2))
  ) %>%
  ggplot(aes(x = x1, y = x2, fill = y)) +
    geom_tile() +
    theme_minimal()

plot2
```

```{r}
gg2 <- mvQuad::createNIGrid(2, "GHe", 3)
gg2
```

The nodes and weights are:

```{r}
mvQuad::getNodes(gg2)
mvQuad::getWeights(gg2)
```

Equivalent to:

```{r}
expand.grid(mvQuad::getNodes(gg), mvQuad::getNodes(gg))
cbind(apply(expand.grid(mvQuad::getWeights(gg), mvQuad::getWeights(gg)), 1, prod))
```

```{r}
plot2 +
  geom_point(
    data = mvQuad::getNodes(gg2) %>%
            as.data.frame() %>%
            mutate(weights = mvQuad::getWeights(gg2)), 
    aes(x = V1, y = V2, size = weights, fill = 1),
    col = cbpalette[2]
  )
```

Do the quadrature using:

```{r}
#' Need f to be defined like this for some reason
f <- function(x) {
  apply(x, 1, function(y) prod(exp(-(y^2) / 2)))  
}

mvQuad::quadrature(f, gg2)
```

As compare with the true answer:

```{r}
2 * pi
```

```{r}
# Gauss Hermite Quadrature
# Showing that the nodes are zeros of Hermite polynomial
Hk <- as.function(mpoly::hermite(3, kind = "he"))
nn <- mvQuad::getNodes(gg)
round(Hk(nn))

# Adaptive: scale the nodes and weights by the mode and curvature
theta_hat <- c(2, 3)
theta_hess <- matrix(c(3, 1, 1, 5), nrow = 2, ncol = 2)
theta_hess_inv <- solve(theta_hess)
k <- 3

# Can be rescaled using mvQuad via
int_grid_software <- mvQuad::createNIGrid(2, "GHe", k)
mvQuad::rescale(int_grid_software, m = theta_hat, C = theta_hess_inv, dec.type = 2)
# or manually via
int_grid_manual <- mvQuad::createNIGrid(2, "GHe", k)
nn_rescaled <- mvQuad::getNodes(int_grid_manual) %*% chol(theta_hess_inv)
nn_rescaled[, 1] <- nn_rescaled[, 1] + theta_hat[1]
nn_rescaled[, 2] <- nn_rescaled[, 2] + theta_hat[2]
# and for the weights
mvQuad::getWeights(int_grid_software)
ww_rescaled <- mvQuad::getWeights(int_grid_manual) * det(chol(theta_hess_inv))

# k = 1 then ACHQ is a Laplace approximation
```

# Tomato disease example

```{r}
library(TMB)
data("tswv", package = "EpiILMCT")

precompile()
compile("disease.cpp")
dyn.load(dynlib("disease"))

dat <- tswv$tswvsir
dat$epidat <- dat$epidat[order(dat$epidat[, 4]), ]
I <- dat$epidat[, 4]
R <- dat$epidat[, 2]
infected <- !is.infinite(I)

datlist <- list(
  D = as.matrix(dist(dat$location[dat$epidat[, 1], ])),
  I = I,
  R = R,
  infected = as.numeric(infected[infected])
)

ff <- TMB::MakeADFun(
  data = datlist,
  parameters = list(theta1 = 0, theta2 = 0),
  DLL = "disease",
  ADreport = FALSE,
  silent = TRUE
)

tm <- Sys.time()
# c(0, 0) is start and k = 7, ilm = individual-level model (?)
tmp <- capture.output(
  ilmquadrature <- aghq::aghq(ff, 7, c(0, 0))
)
runtime <- difftime(Sys.time(), tm, units = "secs")

summary(ilmquadrature)

# compute_moment is the mean (only?)
ilm_means <- aghq::compute_moment(ilmquadrature$normalized_posterior, function(x) exp(x))
names(ilm_means) <- c("alpha", "beta")

# q is a vector of numeric values in (0, 1) giving the quantiles you want
my_q <- c(0.025, 0.1, 0.5, 0.9, 0.975)
exp(aghq::compute_quantiles(ilmquadrature$marginals[[1]], q = my_q)) # alpha
exp(aghq::compute_quantiles(ilmquadrature$marginals[[2]], q = my_q)) # beta
```
