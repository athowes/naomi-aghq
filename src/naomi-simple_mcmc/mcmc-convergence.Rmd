---
title: "MCMC convergence diagnostics"
author:
- name: Adam Howes
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
bibliography: citations.bib
abstract: |
  **Background** In the report `naomi-simple_fit` with parameter `tmbstan = TRUE`, we used the NUTS algorithm to perform MCMC inference for the simplified Naomi model.
  
  **Task** Here we assess whether or not the results of the MCMC are suitable using a range of diagnostic tools.
---

We start by obtaining results from the latest version of `naomi-simple_fit` with `tmbstan = TRUE`.

```{r}
out <- readRDS("depends/out.rds")
mcmc <- out$mcmc$stanfit
```

This MCMC took `r round(out$time, 3)` days to run

```{r}
cbpalette <- c("#56B4E9", "#009E73", "#E69F00", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")

bayesplot::color_scheme_set("viridisA")
ggplot2::theme_set(theme_minimal())
```

# $\hat R$

We are looking for values of $\hat R$ less than 1.1 here. 

```{r}
rhats <- bayesplot::rhat(mcmc)

bayesplot::mcmc_rhat_data(rhats) %>%
  ggplot(aes(x = value, y = parameter, col = description)) +
  geom_segment(aes(yend = parameter, xend = ifelse(min(value) < 1, 1, -Inf)), na.rm = TRUE, alpha = 0.7) +
  scale_color_manual(values = "#E69F00") +
  geom_vline(xintercept = 1.05, linetype = "dashed", col = "grey40") +
  labs(x = "Potential scale reduction factor", y = "NUTS parameter", col = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank()
  )

ggsave("rhat.png", h = 3, w = 6.25)

(big_rhats <- rhats[rhats > 1.1])
length(big_rhats) / length(rhats)
```

# ESS ratio

Reasonable to be worried about values less than 0.1 here.

```{r}
ratios <- bayesplot::neff_ratio(mcmc)

breaks <- c(0, 0.1, 0.25, 0.5, 0.75, 1)

bayesplot::mcmc_neff_data(ratios) %>%
  ggplot(mapping = aes(x = value, y = parameter, color = description)) +
  geom_segment(aes(yend = parameter, xend = -Inf), na.rm = TRUE, alpha = 0.7) +
  scale_color_manual(values = c("#56B4E9", "#009E73", "#E69F00")) +
  geom_vline(xintercept = 0.1, linetype = "dashed", col = "grey40") +
  geom_vline(xintercept = 0.5, linetype = "dashed", col = "grey40") +
  geom_vline(xintercept = 1, linetype = "dashed", col = "grey40") +
  labs(x = "ESS ratio", y = "NUTS parameter", col = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank()
  )

ggsave("ratio.png", h = 3, w = 6.25)
```

# ESS

What are the total effective sample sizes?

```{r}
#' I think that this $summary should be all of the chains grouped together
mcmc_summary <- summary(mcmc)$summary

data.frame(mcmc_summary) %>%
  tibble::rownames_to_column("param") %>%
  ggplot(aes(x = n_eff)) +
    geom_histogram(alpha = 0.8) +
    labs(x = "ESS", y = "Count")

ggsave("ess.png", h = 3, w = 6.25)
```

# Autocorrelation

How much autocorrelation is there in the chains?

```{r}
bayesplot::mcmc_acf(mcmc, pars = vars(starts_with("beta")))
```

# Univariate traceplots

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("beta")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("logit")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("log_sigma")))
```

## Prevalence model

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_rho_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_rho_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_a[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_as[")))
```

## ART model

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_alpha_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_alpha_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_a[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_as[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_xa[")))
```

## Other

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("ui_lambda_x[")))
```

## ANC model

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("ui_anc_rho_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("ui_anc_alpha_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("log_or_gamma["))) #' N.B. these are from the ANC attendance model
```

# Pairs plots

## Paired PCA parameters

Variation between units can be explained by high correlation and high standard deviation, or low correlation and low standard deviation.
Hence there is an unidentifiabiility here that leads to correlated posteriors.

```{r}
bayesplot::mcmc_pairs(mcmc, pars = c("log_sigma_alpha_as", "logit_phi_alpha_as"), diag_fun = "hist", off_diag_fun = "hex")
bayesplot::mcmc_pairs(mcmc, pars = c("log_sigma_rho_as", "logit_phi_rho_as"), diag_fun = "hist", off_diag_fun = "hex")
bayesplot::mcmc_pairs(mcmc, pars = c("log_sigma_alpha_a", "logit_phi_alpha_a"), diag_fun = "hist", off_diag_fun = "hex")
(plot <- bayesplot::mcmc_pairs(mcmc, pars = c("log_sigma_rho_a", "logit_phi_rho_a"), diag_fun = "hist", off_diag_fun = "hex"))

ggsave("rho_a.png", plot, h = 4, w = 6.25)
```

## ART attendance

There is a prior suspicion (from Jeff, Tim, Rachel) that the ART attendance model is unidentifiable.
Let's have a look at the pairs plot for neighbouring districts and the `log_or_gamma` parameter.

```{r}
area_merged <- sf::read_sf(system.file("extdata/demo_areas.geojson", package = "naomi"))

nb <- area_merged %>%
  filter(area_level == max(area_level)) %>%
  bsae::sf_to_nb()

neighbours_pairs_plot <- function(par, i) {
  neighbour_pars <- paste0(par, "[", c(i, nb[[i]]), "]")
  bayesplot::mcmc_pairs(mcmc, pars = neighbour_pars, diag_fun = "hist", off_diag_fun = "hex")
}

# area_merged %>%
#   filter(area_level == max(area_level)) %>%
#   print(n = Inf)
```

Here are Nkhata Bay and neighbours:

```{r}
neighbours_pairs_plot("log_or_gamma", 5) 
```

And here are Blantyre and neighbours:

```{r}
neighbours_pairs_plot("log_or_gamma", 26)
```

# NUTS specific assessment

```{r}
np <- bayesplot::nuts_params(mcmc)

saveRDS(np, "nuts-params.rds")
```

Are there any divergent transitions?

```{r}
np %>%
  filter(Parameter == "divergent__") %>%
  summarise(n_divergent = sum(Value))

bayesplot::mcmc_nuts_divergence(np, bayesplot::log_posterior(mcmc))
```

We can also use energy plots [@betancourt2017conceptual]: ideally these two histograms would be the same 
When the histograms are quite different, it may suggest the chains are not fully exploring the tails of the target distribution.

```{r}
bayesplot::mcmc_nuts_energy(np)
```

# Original computing environment {-}

```{r}
sessionInfo()
```

# Bibliography {-}
