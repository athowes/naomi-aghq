---
title: "MCMC convergence diagnostics"
author:
- name: Adam Howes
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    toc_collapsed: yes
    df_print: paged
    code_folding: show
    theme: lumen
bibliography: citations.bib
abstract: |
  **Background** In the report `naomi-simple_fit` with parameter `tmbstan = TRUE`, we used the NUTS algorithm to perform MCMC inference for the simplified Naomi model.
  
  **Task** Here we assess whether or not the results of the MCMC are suitable using a range of diagnostic tools.
---

We start by obtaining results from the latest version of `naomi-simple_fit` with `tmbstan = TRUE`.

```{r}
out <- readRDS("depends/out.rds")
mcmc <- out$mcmc$stanfit
```

This MCMC took `r round(out$time, 3)` days to run

```{r}
cbpalette <- c("#56B4E9", "#009E73", "#E69F00", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")

bayesplot::color_scheme_set("viridisA")
ggplot2::theme_set(theme_minimal())
```

# $\hat R$

We are looking for values of $\hat R$ less than 1.1 here. 

```{r}
rhats <- bayesplot::rhat(mcmc)

rhat_plot <- mcmc_rhat_data(rhats) %>%
  ggplot(mapping = aes_(x = ~value, y = ~parameter, col = ~description)) +
  geom_segment(mapping = aes_(yend = ~parameter, xend = ifelse(min(data$value) < 1, 1, -Inf)), na.rm = TRUE, alpha = 0.7) +
  scale_color_manual(values = "#E69F00") +
  geom_vline(xintercept = 1.05, linetype = "dashed", col = "grey40") +
  labs(x = "Potential scale reduction factor", y = "NUTS parameter", col = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank()
  )

rhat_plot

pdf("rhat.pdf", h = 3, w = 6.25)

rhat_plot

dev.off()

(big_rhats <- rhats[rhats > 1.1])
length(big_rhats) / length(rhats)

```

# ESS ratio

Reasonable to be worried about values less than 0.1 here.

```{r}
ratios <- bayesplot::neff_ratio(mcmc)

breaks <- c(0, 0.1, 0.25, 0.5, 0.75, 1)

ratio_plot <- mcmc_neff_data(ratios) %>%
  ggplot(mapping = aes_(x = ~value, y = ~parameter, color = ~description)) +
  geom_segment(aes_(yend = ~parameter, xend = -Inf), na.rm = TRUE, alpha = 0.7) +
  scale_color_manual(values = c("#56B4E9", "#009E73", "#E69F00")) +
  geom_vline(xintercept = 0.1, linetype = "dashed", col = "grey40") +
  geom_vline(xintercept = 0.5, linetype = "dashed", col = "grey40") +
  geom_vline(xintercept = 1, linetype = "dashed", col = "grey40") +
  labs(x = "ESS ratio", y = "NUTS parameter", col = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank()
  )

ratio_plot

pdf("ratio.pdf", h = 3, w = 6.25)

ratio_plot

dev.off()
```

# ESS

What are the total effective sample sizes?

```{r}
#' I think that this $summary should be all of the chains grouped together
mcmc_summary <- summary(mcmc)$summary

ess_plot <- data.frame(mcmc_summary) %>%
  tibble::rownames_to_column("param") %>%
  ggplot(aes(x = n_eff)) +
    geom_histogram(alpha = 0.8) +
    labs(x = "ESS", y = "Count")

ess_plot

pdf("ess.pdf", h = 3, w = 6.25)

ess_plot

dev.off()
```

# Autocorrelation

How much autocorrelation is there in the chains?

```{r}
bayesplot::mcmc_acf(mcmc, pars = vars(starts_with("beta")))
```

# Univariate traceplots

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("beta")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("logit")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("log_sigma")))
```

## Prevalence model

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_rho_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_rho_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_a[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_rho_as[")))
```

## ART model

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_alpha_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("us_alpha_xs[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_a[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_as[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("u_alpha_xa[")))
```

## Other

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("ui_lambda_x[")))
```

## ANC model

```{r}
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("ui_anc_rho_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("ui_anc_alpha_x[")))
bayesplot::mcmc_trace(mcmc, pars = vars(starts_with("log_or_gamma["))) #' N.B. these are from the ANC attendance model
```

# Pairs plots

There is a prior suspicion (from Jeff, Tim, Rachel) that the ART attendance model is unidentifiable.
Let's have a look at the pairs plot for neighbouring districts and the `log_or_gamma` parameter.

```{r}
area_merged <- sf::read_sf(system.file("extdata/demo_areas.geojson", package = "naomi"))

nb <- area_merged %>%
  filter(area_level == max(area_level)) %>%
  bsae::sf_to_nb()

neighbours_pairs_plot <- function(par, i) {
  neighbour_pars <- paste0(par, "[", c(i, nb[[i]]), "]")
  bayesplot::mcmc_pairs(mcmc, pars = neighbour_pars, diag_fun = "hist", off_diag_fun = "hex")
}

# area_merged %>%
#   filter(area_level == max(area_level)) %>%
#   print(n = Inf)
```

Here are Nkhata Bay and neighbours:

```{r}
neighbours_pairs_plot("log_or_gamma", 5) 
```

And here are Blantyre and neighbours:

```{r}
neighbours_pairs_plot("log_or_gamma", 26)
```

# NUTS specific assessment

```{r}
np <- bayesplot::nuts_params(mcmc)

saveRDS(np, "nuts-params.rds")
```

Are there any divergent transitions?

```{r}
np %>%
  filter(Parameter == "divergent__") %>%
  summarise(n_divergent = sum(Value))

bayesplot::mcmc_nuts_divergence(np, bayesplot::log_posterior(mcmc))
```

We can also use energy plots [@betancourt2017conceptual]: ideally these two histograms would be the same 
When the histograms are quite different, it may suggest the chains are not fully exploring the tails of the target distribution.

```{r}
bayesplot::mcmc_nuts_energy(np)
```

# Original computing environment {-}

```{r}
sessionInfo()
```

# Bibliography {-}
